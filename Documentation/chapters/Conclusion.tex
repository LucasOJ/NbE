\chapter{Conclusion}
\label{chap:conclusion}

% {\bf A compulsory chapter,     of roughly $5$ pages} 

% \noindent
% The concluding chapter of a dissertation is often underutilised because it 
% is too often left too close to the deadline: it is important to allocation
% enough attention.  Ideally, the chapter will consist of three parts:
% 
% \begin{enumerate}
% \item (Re)summarise the main contributions and achievements, in essence
%       summing up the content.
% \item Clearly state the current project status (e.g., ``X is working, Y 
%       is not'') and evaluate what has been achieved with respect to the 
%       initial aims and objectives (e.g., ``I completed aim X outlined 
%       previously, the evidence for this is within Chapter Y'').  There 
%       is no problem including aims which were not completed, but it is 
%       important to evaluate and/or justify why this is the case.
% \item Outline any open problems or future plans.  Rather than treat this
%       only as an exercise in what you {\em could} have done given more 
%       time, try to focus on any unexplored options or interesting outcomes
%       (e.g., ``my experiment for X gave counter-intuitive results, this 
%       could be because Y and would form an interesting area for further 
%       study'' or ``users found feature Z of my software difficult to use,
%       which is obvious in hindsight but not during at design stage; to 
%       resolve this, I could clearly apply the technique of Smith [7]'').
% \end{enumerate}

% Summary of what we did 
%   3 variations
%   possible to translate Agda implementation to Haskell with type guarentees

In this dissertation we produced three variations of NbE. The first normalised named, untyped lambda calculus using the Gensym approach, following an implementation by Lindley \cite{slides}. Issues with fresh variable names inspired a second implementation for untyped de Bruijn terms which we adapted from a specification by Abel \cite{deBruijn}. We used GADTs to define the STLC in Haskell, before successfully translating an implementation of NbE for the SLTC by Kovacs \cite{AgdaNbe} from Agda to Haskell. We found that GHC compiler extensions are powerful enough to emulate some features of dependently typed languages.

We found that \code{GADTs} is an excellent extension for emulating dependent types when combined with \code{PolyKinds}. GADT syntax allowed us to define types \code{Expr} with much greater precision, and enabled us to translate Agda \code{data} definitions such as \code{OPE} and type generating functions such as $\text{Ty}^\text{N}$. The type-refinement system when pattern matching on GADTs enabled us to write strongly typed functions with ease.
% TODO: rephrase, tALK about eval above
In general, we believe that GADTs are a useful and usable tool for Haskell developers to add type-safety to their programs by taking advantage of the programs as proof paradigm. 

For our implementation, the class instance trick for performing pattern matches on the type worked well, with fairly little amounts of boilerplate. However, as noted in Section \ref{sect:typedNormalisation} for more complex applications with many dependent pattern matches, this boilerplate could become more difficult to manage. Richard Eisenberg's proposals for built-in dependent pattern matches is a much cleaner approach \code{GADTs}, by a syntax similar to Agda. However, the current solution to managing multiple dependent pattern matches is the \code{singleton} library. 

% Evaluation of Haskell language features in terms of typed NbE implementation
%    Singletons worked well, complex applications could struggle
%    Singleton library for automation
%    GADTs with DataKinds "good", type renfinement, moves errors to compile time.
%   Proofs as programs
%    type annotations, inference not as strong as type theories
%    Untyped vs typed speed

One practical reason developers may opt to implement programs in Haskell rather than dependently typed languages is performance. It would be interesting to benchmark the produced SLTC NbE implementation against its Agda counterpart, as a significant difference in performance could be compelling reason to choose one over the other in practice.

Another avenue for future work is to translate Kovacs' full proof of correctness from Agda to Haskell. 

% future work
    % Correctness proofs from \cite{AgdaNbe} translate over
