\chapter{Introduction}
\label{chap:introduction}

Normalisation by evaluation (NbE) is an alternative method of normalisation for lambda terms to reduction-based techniques.

Given a lambda term, normalisation by reduction contracts reducible expressions (redexes) one by one, until the term contains no more redexes. 

In normalisation by evaluation we first interpret the term as an element of a semantic set. We then "reify" the semantic value back into set of lambda terms in normal form. 

This method works when it satisifes the following properies: 

\begin{enumerate}
    \item Terms with identical normal forms evaluate to the same semantic element. This forms an equivalence class of terms which are convertible modulo evaluation.
    \item Normalising terms that are already normal yields the same term (ie the normalisation function is idempotent)
\end{enumerate}


Normalisation by evaluation is well-studied (cite) and used in the implementation of proof-assistants (cite)


% Want more of a narrative:

% Introduction to type theories 
%   Intro to Dependent types
% Type checking depent types
%   Naturally leads to desire for efficient equality checks between programs at type level 
% Problems with reduction-based approaches
%   It feels wrong for equality to be based on directed notions
%   eta-long form not directed 
%   Not efficient??
%   Rewriting difficult to reason about mathematically (operating on syntax)
% Resolution: NbE
%   Undirected approach
% How does NbE work?
%   Eval + Reify
%   Semantic set
%   Sound + complete
% Why better?
%   Leans into idea of equivalence between terms (terms with equivalent meanings are equivalent!!)
%   Eta-long form is easy to extract
%   Enforced by theory
%       Built from mathematics, much more convinient to make proofs of correctness
% What is this project about?
% About Haskell
%   Haskell is lazy functional
%   Widest adoption of pure functional lanaguages
%   Not initally built to support complex types (ie dependent)
%       Type erasure for efficiency
%   Modern compiler extentions support more complex programs at type level

The aims of this dissertation are to:
\begin{itemize}
    \item Implement normalisation by evaluation for the typed and untyped Lambda Calculus in Haskell
    
    % TODO: Rephase this
    \item Investigate modern typing features of Haskell, particularly how useful they are in developing dependently typed programs and how the implementation compares to dependently typed languages.
\end{itemize}