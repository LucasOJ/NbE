\chapter{Normalising the Typed Lambda Calculus}
\label{chap:typednbe}

In this chapter, we translate an Agda implementation of NbE developed by Andras Kovacs \cite{AgdaNbe} for the STLC into Haskell.

\section{Target Syntax}

% TODO: Colour for polymorphic type variable in certain blocks

We construct set of the simply typed normal terms \code{NormalForm} by combining the approach seen for the untyped terms in Chapter \ref{chap:untypednbe} with the GADT syntax from Chapter \ref{chap:typedlamadacalculus} to ensure the inhabitants are well-typed.

\begin{lstlisting}
    data NormalForm :: [Ty] -> Ty -> * where
        NormalNeutral :: NeutralForm ctx ty -> NormalForm ctx ty
        NormalLam :: NormalForm (arg ': ctx) result -> NormalForm ctx (arg :-> result)    

    data NeutralForm :: [Ty] -> Ty -> * where
        NeutralVar :: Elem ctx ty -> NeutralForm ctx ty
        NeutralApp :: NeutralForm ctx (arg :-> result) -> NormalForm ctx arg 
                   -> NeutralForm ctx result

\end{lstlisting}

% TODO: Justify why V has context (need to reify, example, normalise identity), describe what we need



% TODO: First evaluation problem - returning correct semantic context, lambda has different syntax
% - Solved for us by Andras

% TODO: Correspondence with untyped env, Motivate need for tracking type, ctxV

\section{Order Preserving Embeddings}

In the lambda case of \code{eval}, NbE evaluates the body of the lambda in a stronger context where a new bound variable is introduced (as seen in Chapter \ref{chap:untypednbe}). To continue the evaluation of the body ...

\begin{lstlisting}
    data OPE :: [Ty] -> [Ty] -> * where
        Empty :: OPE '[] '[]
        Drop  :: OPE ctx1 ctx2 -> OPE (x : ctx1) ctx2
        Keep  :: OPE ctx1 ctx2 -> OPE (x : ctx1) (x : ctx2)
\end{lstlisting}

A value of type \code{OPE a b} is a proof that the list of types \code{b} is a subsequence of \code{a}. The three constructors correspond to the different ways of constructing such a proof. The \code{Empty} constructor corresponds to the trivial case that the empty list contains itself. Given a proof that \code{ctx2} is embedded in \code{ctx1}, the \code{Drop} constructor extends the proof to show that \code{ctx2} is embedded in \code{x:ctx1}, and the \code{Keep} constructor extends the proof to show that \code{x:ctx2} is embedded in \code{x:ctx1}. For example, \code{Drop (Keep Empty))} could have the (Haskell) type \code{OPE '[BaseTy :-> BaseTy, BaseTy] '[BaseTy]}.

% Q: Order changes dB Indices if drop from middle?

% TODO: Motivate why need in terms of eval, read Andras Paper

\section{Semantic Set}

The normalisation function should return a \code{NormalForm} with the same type and typing context as the original term, so should have the type signature \code{Expr ctx ty $\rightarrow$ NormalForm ctx ty}. Because \code{reify} is a pure function of the semantic set \code{V}, this set must also be indexed by the typing context and type of the expression to preserve the typing information (as seen in the kind signature below). 

\begin{lstlisting}
    data V :: [Ty] -> Ty -> * where 
        Base :: NormalExpr ctx BaseTy -> V ctx BaseTy
        Function :: (forall ctx' .  OPE ctx' ctx -> V ctx' arg -> V ctx' result) 
                 -> V ctx (arg :-> result)
\end{lstlisting}

The semantic set for typed NbE is the key difference between the typed and untyped implementations of NbE this dissertation presents. 

% TODO: Justify

The \code{Base} constructor specifies that values of \code{V}with type \code{BaseTy} are normal forms. The \code{Function} constructor creates a value of function type \code{arg :-> result} given a function with type signature 
\begin{lstlisting}
    forall ctx' . OPE ctx' ctx -> V ctx' arg -> V ctx' result 
\end{lstlisting}

By default, in GHC, there is only have one “level” of polymorphism, where type variables are implicitly universally quantified. However, within the function type signature above, we want to treat \code{ctx} as fixed, and quantify over all larger contexts. To achieve this we use higher-ranked polymorphism with the explicit \code{forall} syntax to delay the quantification of \code{ctx'} until after \code{ctx} has been bound. Then, by treating \code{OPE} as a relation on typing contexts, we specify that \code{ctx'} must be larger than \code{ctx}. We can think of the \code{OPE} argument as a predicate on the quantification, in that the function first takes a proof that \code{ctx'} contains \code{ctx}. To enable higher ranked polymorphism, we use the \code{Rank2Types} extension. The result is that the \code{Function} constructor takes a function with partially applied type \code{V ctx' arg $\rightarrow$ V ctx' result} where \code{ctx'} is any contexr larger than the original context, and returns a semantic value in the original context with type \code{arg :-> result}

% TODO: Motivation for structure

\section{Evaluation}

\subsection{Environment}

\begin{lstlisting}
    data Env :: [Ty] -> [Ty] -> * where
        EmptyEnv :: Env '[] ctxV
        ConsEnv  :: Env ctx ctxV -> V ctxV ty -> Env (ty : ctx) ctxV
\end{lstlisting}

\begin{lstlisting}
    envLookup :: Elem ctx ty -> Env ctx ctxV -> V ctxV ty 
    envLookup Head     (ConsEnv _    v) = v
    envLookup (Tail n) (ConsEnv prev _) = envLookup n prev
\end{lstlisting}

\subsection{Variable Case}

\begin{lstlisting}
    eval :: Env ctx ctxV -> Expr ctx ty -> V ctxV ty
    eval env (Var n) = envLookup n env
\end{lstlisting}

\subsection{Lambda Case}

\begin{lstlisting}
    eval (env :: Env ctx ctxV) (Lam (body :: Expr (arg:ctx) result)) = Function f 
        where
            f :: (SingContext ctxV') => OPE ctxV' ctxV -> V ctxV' arg -> V ctxV' result
            f ope v = eval (ConsEnv (strengthenEnv ope env) v) body
\end{lstlisting}

%TODO: Scoped Type variables
% - Show what types are inferred without

% TODO: Remove singletons

\begin{lstlisting}
    strengthenElem :: OPE strong weak -> Elem weak ty -> Elem strong ty
    strengthenElem Empty      v        = v
    strengthenElem (Drop ope) v        = Tail (strengthenElem ope v)
    strengthenElem (Keep ope) Head     = Head
    strengthenElem (Keep ope) (Tail v) = Tail (strengthenElem ope v)

    strengthenNormal :: OPE strong weak -> NormalExpr weak ty -> NormalExpr strong ty
    strengthenNormal ope (NormalNeutral n) = NormalNeutral (strengthenNeutral ope n)
    strengthenNormal ope (NormalLam n)     = NormalLam (strengthenNormal (Keep ope) n)

    strengthenNeutral :: OPE strong weak -> NeutralExpr weak ty -> NeutralExpr strong ty
    strengthenNeutral ope (NeutralVar n)   = NeutralVar (strengthenElem ope n)
    strengthenNeutral ope (NeutralApp f a) = NeutralApp (strengthenNeutral ope f) (strengthenNormal ope a) 

    strengthenV :: (SingContext strong) => OPE strong weak -> V weak ty -> V strong ty
    strengthenV ope                      (Base nf) = Base (strengthenNormal ope nf)
    strengthenV (ope :: OPE strong weak) (Function (f :: forall strong . (SingContext strong) => OPE strong weak -> V strong arg -> V strong result)) = Function f' 
        where
            f' :: (SingContext stronger) => OPE stronger strong -> V stronger arg -> V stronger result
            f' ope' = f (composeOPEs ope ope')
    
    strengthenEnv :: (SingContext c) => OPE c b -> Env a b -> Env a c
    strengthenEnv _   EmptyEnv         = EmptyEnv
    strengthenEnv ope (ConsEnv tail v) = ConsEnv (strengthenEnv ope tail) (strengthenV ope v)
\end{lstlisting}

\subsection{Application Case}

%TODO: Motivate by pattern matching on type not possible in Haskell

\begin{lstlisting}
    eval env (App f a) = appV (eval env f) (eval env a) 
        where
            appV (Function f') a' = f' (idOPEFromEnv env) a'

            idOPEFromEnv :: (SingContext ctxV) => Env ctx ctxV -> OPE ctxV ctxV
            idOPEFromEnv _ = idOpe 
\end{lstlisting}

\begin{lstlisting}
    class SingContext ctx where
        idOpe :: OPE ctx ctx

    instance SingContext '[] where
        idOpe = Empty

    instance (SingContext xs, SingTy x) => SingContext (x:xs) where
        idOpe = Keep idOpe
\end{lstlisting}

%TODO Include code link

\section{Reification}

\begin{lstlisting}
    reify :: V ctx ty -> NormalExpr ctx ty
    reify (Base nf)    = nf
    reify (Function f) = NormalLam (reify (f ope (evalNeutral (NeutralVar Head)))) 
        where
            ope = weakenContext (Function f)

            weakenContext :: (SingContext ctx) => V ctx ty -> OPE (x:ctx) ctx
            weakenContext _ = wk 

    evalNeutral :: (SingTy ty, SingContext ctx) => NeutralExpr ctx ty -> V ctx ty
    evalNeutral = evalNeutral' singTy

    evalNeutral' :: (SingContext ctx) => STy ty -> NeutralExpr ctx ty -> V ctx ty
    evalNeutral' SBaseTy       n                                       = Base (NormalNeutral n)  
    evalNeutral' (SArrow _ _)  (n :: NeutralExpr ctx (arg :-> result)) = Function f 
        where
            f :: (SingContext strongerCtx) => OPE strongerCtx ctx -> V strongerCtx arg -> V strongerCtx result
            f ope v = evalNeutral (NeutralApp (strengthenNeutral ope n) (reify v))
\end{lstlisting}

% TODO: Motivate evalNeutral and rename, contrast with standard eval

\begin{lstlisting}
    data STy :: Ty -> * where
        SBaseTy :: STy BaseTy
        SArrow  :: (SingTy a, SingTy b) => STy a -> STy b -> STy (a :-> b)

    class SingTy a where
        singTy :: STy a 

    instance SingTy 'BaseTy where
        singTy = SBaseTy

    instance (SingTy a, SingTy b) => SingTy (a :-> b) where
        singTy = SArrow singTy singTy
\end{lstlisting}

\begin{lstlisting}
    class SingContext ctx where
        idOpe :: OPE ctx ctx
        wk :: OPE (x:ctx) ctx
        wk = Drop idOpe
\end{lstlisting}

\section{Normalisation}

\begin{lstlisting}
    normalise :: (SingContext ctx) => Expr ctx ty -> NormalExpr ctx ty
    normalise = reify . eval initialEnv
\end{lstlisting}

\begin{lstlisting}
    class SingContext ctx where
        idOpe :: OPE ctx ctx
        wk :: OPE (x:ctx) ctx
        wk = Drop idOpe
        initialEnv :: Env ctx ctx

    instance SingContext '[] where
        idOpe = Empty
        initialEnv = EmptyEnv

    instance (SingContext xs, SingTy x) => SingContext (x:xs) where
        idOpe = Keep idOpe
        initialEnv = ConsEnv (strengthenEnv wk initialEnv) (evalNeutral (NeutralVar Head))
\end{lstlisting}

\section{Notes}

Investigation: Are GADTs in Haskell powerful enough? Types are erased at runtime so true dependent typing not part of Haskell (programs at type level)

Advantage over ADTs: type refinement by constructor

Poissible to erase all type information, NbE on Untyped
Issue: No proof that type preserved 
Solution: Track types as do evaluation - nbe program itself proof that types preserved (subject reduction parallel?)

Started by implementing same as untyped

Main difference in semantics (V := a -> b | Neutral) 
\cite{slides}

problem: Need to strengthen context evaluating body (eval Lam case)
\subsection{Solution: Order Preserving Embeddings (OPEs)}

Following implementation in Agda \cite{AgdaNbe}, agda has full dependent types (type system more powerful) - adapt for haskell, how nicely? 

if a term well typed for one context, also well typed for any longer one

A value of type 'OPE strong weak' can derive weak from strong by dropping elements from context

OPE is a relation on typing contexts

\subsection{Semantic set}

Defintion of V using OPEs - Haskell vs agda

Need to quantify over 'strong' in function - OPE strong weak is guarentee that strong is a stronger context than weak (if quantified at start end up with values where weak stronger than strong) - need rank2 types extension for nested quantification

Helper functions (composition, strengthing relative to OPE) - explain derivations

\subsection{implementing Eval}

Defintion of environment (maps expressions in syntax context ctx to values in semantics with context ctxV)

problem: in app case how to we get identity OPE for semantic context?

But types erased at compile time to make Haskell efficient

How to generate a value at runtime dependent on type erased at compile time

dependent pattern match \cite{SingletonsGuide}

\subsection{Solution: Singleton pattern}

Method of Type to value known as reflection \cite{SingletonsGuide}

Idea: Create value-level tags for types - singleton types correspond type we're interested in, inhabited by only one value for each case

Examples: Reify case analysis, Ty reflection, Context reflection

Explicitly passing as value to pattern match on

Generate implictly using typeclass, use class constraint to imiplictly pass down ability to use contex methods through function calls.
Is it a good idea to have class constraints in the GADTs/Syntax definitions?

Implementation in class vs full reflection - test this for speed?

problem : Inferring Any for ctxV (why?)

solution: scoped type variables - universally quantified variables used in type expressions bind over 'where' clause

(More usefully) can 'unpack' refined GADT types so that can create type definitions using refined types.

Analysis:

Have to specify type when normaling for correct eta-expansion (eta-long form)

Qs:
How does locally nameless work in sematics?
How does ctxV work in Env?
