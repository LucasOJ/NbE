\chapter{Representation of the Simply Typed Lambda Calculus}
\label{chap:typedlamadacalculus}

Before implementing NbE for the STLC, we define datatypes representing the typed lambda calculus in Haskell. 

\section{Types}

We first define a type syntax to represent the monotypes of the simply typed lambda calculus. 

\begin{lstlisting}
    data Ty = BaseTy | Ty :-> Ty 
    infixr 9 :->
\end{lstlisting}

In this type syntax there is a single base type \code{BaseTy} and an infix type constructor \code{:->}, where the type \code{A :-> B} represents the function type from type \code{A} to type \code{B}. For this implementation of NbE, a single base type is sufficient to capture the structure of simple types. Multiple base types would have introduced unnecessary complexity.
%TODO: Justify why, type checking?
Normalising terms with polymorphic types is beyond the scope of this project.
 
\code{infixr :-> 9} specifies that \code{:->} is right associative, so as per convention, the type \code{A :-> (B :-> C)} can instead be written \code{A :-> B :-> C}.

\section{Typed terms}

For typed NbE, we only normalise well-typed terms of the lambda calculus. Although well-typed terms are a subset of the untyped terms, the definition of untyped terms from Chapter \ref{chap:untypednbe} doesn't carry enough information to check that terms are well-typed. Instead, we define a richer definiton of typed terms that carry type information proposed by Richard Eisenberg \cite{GADTs}. This information will be stored in the Haskell type of each term value by utilising compiler extensions for GHC. 
% Well-typed by contruction better for haskell than type checking 

\subsection{GADTs}

\cite{GADTs}
Explicit type constructor arguments
Language extensions:
DataKinds, TypeOperators, PolyKinds, GADTs.

Example 1: Vec - indexed type advantage since total function

Fails for replicate without work \cite{DependentHaskell}

Advantage over ADTs: type refinement by constructor

Justification of base type \textit{extension work??: string/integer type}
Example 2: IsElem - value as proof
Example 3: Expr - all values well typed by construction

Difference between [] and '[] (kinds vs types) in terms of levels

Input/Ouput type as pre-condition/post-condition (eg empty context)
