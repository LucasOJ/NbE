\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{biblatex}
\addbibresource{bibliography.bib}

\title{Variations on Normalisation by Evaluation for the Lambda Calculus }
\author{Lucas O'Dowd-Jones}
\date{}

\begin{document}

\maketitle

\section{Introduction}
\subsection{What is NbE?}
Indentify common features - eval and reify, interpret by semantic set in "host" language

Difference to reduction-based

\subsection{Motivation for NbE}

More efficient?

Avoids infinite reduction (terms not strongly normalisable - eg K x omega)

\subsection{Why NbE in Haskell?}

Modern technqiues for elegant implementation (GADTs)

\section{NbE for the Untyped Lambda Calculus}
\subsection{Syntax}
\begin{align}
    N_f &:= N_e \mid \lambda.N_f  \\
    N_e &:= N_e N_f \mid n
\end{align}
\cite{slides}

\subsection{Semantics}
Interpreted by the set V \cite{slides}
$$
    V := N_e \mid V \rightarrow V
$$

Problem: fresh variables

\subsection{Fresh variables solution 1 - Gensym}
approach based on \cite{slides}

Implemented with State monad

Issue with solution 1: Have to add monad everywhere (inescapable) - all functions dependent on state

"Less functional" - carry around state (may as well use imperative)

\subsection{Fresh variables solution 2 - Locally nameless terms}
approach based on \cite{deBruijn}

Uses de Bruijn Indicies for syntax and deBruijn levels for semantics

index n references nth abstraction,
if m abstractions: if n < m bound variables, otherwise free variable

Shifting for abstractions

\section{Implementing the Typed Lambda Calculus}
Problem: Only want to normalise well typed terms.
Criteria: 
(1) Exclude $\lambda x . y$ - y free variable so not in typing context
(2) Exclude $\lambda x.xx$ - untypable (types are finite)

Problem with standard terms - can't carry type information

\subsection{Typed Term solution - GADTs}
\cite{GADTs}
Explicit type constructor arguments
Language extensions:
DataKinds, TypeOperators, PolyKinds, GADTs.

Example 1: Vec 

Justification of base type \textit{extension work??: string/integer type}
Example 2: IsElem
Example 3: Expr

Big-step evalulator

Input/Ouput type as pre-condition/post-condition (eg empty context)

\textit{extension work: Introduce context at value level (parameter to function)} 

Restricitions on Haskell
Not full dependent types - need singleton pattern

\section{NbE for the Typed Lambda Calculus}
Investigation: Are GADTs in Haskell powerful enough? Types are erased at runtime so true dependent typing not part of Haskell (programs at type level)

Poissible to erase all type information, NbE on Untyped
Issue: No proof that type preserved 
Solution: Track types as do evaluation - nbe program itself proof that types preserved (subject reduction parallel?)

Started by implementing same as untyped

Main difference in semantics (V := a -> b | Neutral) 
\cite{slides}

\subsection{Transform to Weaker typed}
Version where we ignore context keep types

\subsection{Full typed}
problem: Need to strengthen context evaluating body (eval Lam case)
\subsection{Strength context solution 1 - Kripke Quantification}
GADT - if holds for a context then also holds for longer one
\subsection{Strengthen context solution 2 - Use closure instead of function}

problem: locally nameless types in semantics
\subsection{deBruijn Levels}
FinOrd GADT - number of elements in context is length of context
Are GADTs in Haskell flexible enough?

\cite{modalTypes}

\printbibliography

\end{document}